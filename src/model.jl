"""
    model(P::Dict{Symbol, Any})

Using the parameters `P` generated by `std_pars(num_loci)`, run the Worm Model and return the results as a dictionary.
"""
function model(P::Dict{Symbol, Any})

	# meta parameters
	debug::Bool = P[:debug]
	cross::Bool = P[:cross]
	prgmt::Bool = P[:progress]

	T::Float64     = P[:T] * 365.0 # timescale years -> days?
	num_itns::Int  = P[:num_itns]  # no. of iterations
	num_recs::Int  = P[:num_recs]  # record resolution (num per itn)
	num_sheep::Int = P[:num_sheep] # no. of sheep in the flock
	num_loci::Int  = P[:num_loci]  # no. of loci
	worms0::Int    = P[:worms0]    # initial no. of worms per sheep


	# (daily) model parameters
	ρ::Float64  = P[:ρ]  # larvae output for females
	μL::Float64 = P[:μL] # larvae mortality rate
	μW::Float64 = P[:μW] # density independent mortality rate
	νW::Float64 = P[:νW] # density dependent mortality rate
	β::Float64  = P[:β]  # ingestion (infection) rate
	# clumping = P[:clumping]  # see Cornell (2003)

	# treatment
	p::Float64 = P[:p] # proportion treated ∈ [0, 1]
	ϕ::Float64 = P[:ϕ] # mixing ∈ [0, 0.5]
	freq_treatments::Int64 = P[:freq_treatments] # e.g. treat 6x per year
	multidrug = P[:multidrug]
	regimen = P[:regimen]

	mix1 = [1 - (1 - p) * ϕ, (1 - p) * ϕ]'
	mix2 = [p * ϕ, 1 - p * ϕ]'

	num_treated = floor(Int, p * num_sheep)    # ∈ [0, num_sheep]
	num_refugia = num_sheep - num_treated      # ∈ [0, num_sheep]
	treated     = 1:num_treated                # 1 .. pN
	refugia     = (num_treated + 1):num_sheep  # pN+1 .. N
	treat_interval = 365 / freq_treatments     # how long until next treatment
	num_drugs = P[:multidrug] ? 2^num_loci : 1 # drug combinations
	
	# sort out treatment schedule
	drug_order = get_drug_order(P)

	# each locus gives a triangular number of combinations
	num_gts = 3^num_loci

	# these need to match the no. of genotypes
	gt_fitness_drug      = calc_gt_fitness(P, fit=:drug)
	gt_fitness_establish = calc_gt_fitness(P, fit=:establish)

	μ_drug = (1 .- gt_fitness_drug) .* treat_interval

	# Storage for results, need:
	# - worm & larvae burden (2)
	# - proportion {susceptible, resistant} worms on {treated, refugia, global} (6)
	# - allele distribution in treated / refugia / global zones (6x loci)
	# - FST and before/after FST (2x loci)
	
	#records = Dict(k => Float64[] for k in (:W, :L, :RT, :RU, :RG, :AT, :AR, :AG, :FST_bg, :FST_ba))
	records = Dict(:W => zeros(num_recs, num_itns),
				   :L => zeros(num_recs, num_itns),
				   :RT => zeros(num_drugs, num_recs, num_itns),
				   :RU => zeros(num_drugs, num_recs, num_itns),
				   :RG => zeros(num_drugs, num_recs, num_itns),
				   :AT => zeros(num_loci, num_recs, num_itns),
				   :AR => zeros(num_loci, num_recs, num_itns),
				   :AG => zeros(num_loci, num_recs, num_itns),
				   :FST_bg => zeros(num_loci, num_recs, num_itns),
				   :FST_ba => zeros(num_loci, num_recs, num_itns))

	rec_width = T / num_recs

	# calculate initial genotype distribution
	gt_distn0 = cross ? a2g(P[:distn0]) : unmixed_a2g(P[:distn0])

	# Variables
	W = zeros(Int, num_gts, num_sheep) # Worms in each sheep
	L = zeros(Int, num_gts, 2)         # Larvae (treated / untreated)
	E = zeros(num_gts, 2)              # Egg genotype distn

	# handy views to subarrays
	W_treated = @view W[:, treated]
	W_refugia = @view W[:, refugia]

	# Temporary variables for calculating FST between treatments
	Wtmp   = zeros(Int, size(W))
	FSTtmp = zeros(num_loci)

	# convenient to store the number of worms like this
	num_worms = zeros(Int, 1, num_sheep)

	# containers for event rates ()
	birth_L = zeros(size(L))
	death_L = zeros(size(L))
	death_W = zeros(size(W))
	# ingestion removed from L then randomly assigned to W
	ingest = zeros(Float64, size(L))

	# temporary arrays for changes
	dW = zeros(Int, size(W))
	dL = zeros(Int, size(L))

	K_birth_L   = zeros(Int, size(L))
	K_death_L   = zeros(Int, size(L))
	K_death_W   = zeros(Int, size(W))
	K_ingest    = zeros(Int, size(L))
	K_establish = zeros(Int, size(W))

	# Set up a handy progress bar
	prog = Progress(num_itns * num_recs, 1)

	tmp_gts = zeros(num_gts)

	for itn in 1:num_itns

		# populate worms with initial genotype frequencies
		W .= rand(Multinomial(worms0, gt_distn0), num_sheep)
		L .= 0
		t  = 0.0
		Wtmp .= 0
		FSTtmp .= 0.0

		dt  = 0.5
		rec = 0
		t_next_rec = 0.0
		treat_pos = 1
		t_next_treat = treat_interval

		while t < T
			# keep records
			while t > t_next_rec && rec < num_recs
				prgmt && next!(prog)
				t_next_rec += rec_width
				rec += 1

				#@show g2a(vec(sum(W[:, treated], dims=2)))
				#@show g2a(vec(sum(W[:, refugia], dims=2)))
				#@show calc_fst(W, num_treated)
				#@show FSTtmp

				records[:W][rec, itn] = sum(W) / num_sheep
				records[:L][rec, itn] = sum(L) / num_sheep
				records[:RT][:, rec, itn] .= prop_res(W_treated, gt_fitness_drug)
				records[:RU][:, rec, itn] .= prop_res(W_refugia, gt_fitness_drug)
				records[:RG][:, rec, itn] .= prop_res(W, gt_fitness_drug)
				records[:AT][:, rec, itn] .= get_alleles(W_treated)
				records[:AR][:, rec, itn] .= get_alleles(W_refugia)
				records[:AG][:, rec, itn] .= get_alleles(W)
				records[:FST_bg][:, rec, itn] = calc_fst(W, num_treated)
				records[:FST_ba][:, rec, itn] = FSTtmp
			end #while

			# Event: treat with drug
			while t > t_next_treat
				drug_to_use = drug_order[ceil(Int, t / treat_interval)]
				#println("itn $itn: treating with $drug_to_use at time $(round(t/365, digits=1))")
				Wtmp .= W
				t_next_treat += treat_interval
				W_treated .= rand.(Binomial.(W_treated, gt_fitness_drug[:, drug_to_use]))
				FSTtmp .= calc_fst([W Wtmp], num_sheep)
			end #while


			# --- Event Rates ---

			# calc egg genotype distribution
			@. E = 0
			num_worms .= sum(W, dims=1)
			for sheep in 1:num_sheep
				W_sheep = @view W[:, sheep]
				# need at least 2 worms to reproduce
				if num_worms[sheep] >= 2
					if cross
						tmp_gts .= num_worms[sheep] .* a2g(g2a(W_sheep))
					else
						tmp_gts .= W_sheep
					end #if
					E .+= (sheep <= num_treated ? mix1 : mix2) .* tmp_gts
				end #if
			end #for

			# This is where the eggs are mixed up on pasture
			# note: vec() necessary to get the dimensions right if L is 1-dim
			@. birth_L = ρ * E
			@. death_L = μL * L
			#@. death_W = (μW .+ view(μ_drug, :, regimen) .+ νW * num_worms) .* W
			@. death_W = (μW + νW * num_worms) * W
			@. ingest  = β * L

			# --- Apply Timestep ---

			# quick hack, fix this later
			dt *= 1.2

			@. dW = 0
			@. dL = 0

			while true
				@. K_birth_L = rand(Poisson(birth_L * dt))
				@. K_death_L = rand(Poisson(death_L * dt))
				@. K_death_W = rand(Poisson(death_W * dt))
				@. K_ingest  = rand(Poisson(ingest * dt))

				# calculation of K_establish is more involved
				ingest!(K_establish, K_ingest, num_treated)
				@. K_establish = rand(Binomial(K_establish, gt_fitness_establish))

				@. dL = + K_birth_L - K_death_L - K_ingest
				@. dW = + K_establish - K_death_W

				# overshoot tests if change leaves variable < 0
				if overshoot(W, dW) || overshoot(L, dL)
					dt /= 2
					continue
				end #if

				break
			end #while

			@. W += dW
			@. L += dL

			# ensure_positive!(W, "W")
			# ensure_positive!(L, "L")

			t += dt
		end #while

		# finish recording if necessary
		while rec < num_recs
			next!(prog)
			rec += 1

			# treated / refugia allele dists
			records[:W][rec, itn] = sum(W) / num_sheep
			records[:L][rec, itn] = sum(L) / num_sheep
			records[:RT][:, rec, itn] .= prop_res(W_treated, gt_fitness_drug)
			records[:RU][:, rec, itn] .= prop_res(W_refugia, gt_fitness_drug)
			records[:RG][:, rec, itn] .= prop_res(W, gt_fitness_drug)
			records[:AT][:, rec, itn] .= get_alleles(W_treated)
			records[:AR][:, rec, itn] .= get_alleles(W_refugia)
			records[:AG][:, rec, itn] .= get_alleles(W)
			records[:FST_bg][:, rec, itn] = calc_fst(W, num_treated)
			records[:FST_ba][:, rec, itn] = FSTtmp
		end #while
	end #for

	t = T * (0 : num_recs - 1) / (365 * num_recs)

	return records, t
end #fn

